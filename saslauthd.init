#!/bin/sh
#
# saslauthd     SASL AUTH Daemon
#
# chkconfig:    345 40 60
# description:  SASL AUTH Daemon
# processname:  saslauthd
# pidfile:      /var/run/saslauthd/saslauthd.pid

### BEGIN INIT INFO
# Provides: saslauthd
# Required-Start: $network $remote_fs
# Required-Stop: $network $remote_fs
# Default-Start: 3 4 5
# Default-Stop: 1 6
# Short-Description: Cyrus SASL auth daemon
# Description: The Cyrus SASL authentication daemon provides authentication
#              services to SASL enabled applications via several mechanisms
### END INIT INFO


# Source function library
. /etc/rc.d/init.d/functions

SASL_AUTHMECH=pam

PROG="saslauthd"
SOCKETDIR="/var/run/${PROG}"
PIDFILE="${SOCKETDIR}/${PROG}.pid"
LOCKFILE="/var/lock/subsys/${PROG}"

#Postfix spool directory (need to have the mux there as well)
PFDIR="/var/spool/postfix"

# We will check if running from old dir and also be sure to provide
# links for the mux socket file for backwards compatibility
OLDSOCKETDIR="/var/lib/sasl2"
OLDPIDFILE="${OLDSOCKETDIR}/${PROG}.pid"

# Get service config
[ -f /etc/sysconfig/saslauthd ] && . /etc/sysconfig/saslauthd

# mech_options must be specified before the auth method (SASL_RIMAP_HOSTNAME
# provided for backwards compatibility)
SASLAUTHD_OPTS="$SASLAUTHD_OPTS ${SASL_MECH_OPTIONS:+"-O $SASL_MECH_OPTIONS"} ${SASL_RIMAP_HOSTNAME:+"-O $SASL_RIMAP_HOSTNAME"} -a $SASL_AUTHMECH"

if [ ! -x "/usr/sbin/${PROG}" -a "$1" != "stop" ]; then
    gprintf "%s needs to exist and be executable\n" "/usr/sbin/${PROG}"
    exit 5
fi

start() {
	gprintf "Starting %s: " $PROG
	[ ! -f $PIDFILE -a -f $OLDPIDFILE ] && local PIDFILE="$OLDPIDFILE"
	daemon --pidfile=$PIDFILE $PROG -m $SOCKETDIR $SASLAUTHD_OPTS
	RETVAL=$?
	echo
	if [ $RETVAL -eq 0 ]; then
		touch $LOCKFILE
    		# Check if Postfix is present and make a hardlink so
		# smtp auth can work
		if [ -e $PFDIR ]; then
			if [ ! -e ${PFDIR}${SOCKETDIR} ]; then
				gprintf "Creating %s\n" "${PFDIR}${SOCKETDIR}"
				mkdir -p ${PFDIR}${SOCKETDIR} ${PFDIR}${OLDSOCKETDIR}
			fi
			if [ ! -e ${PFDIR}${SOCKETDIR}/mux ];then
				if [ ! -e $SOCKETDIR/mux ];then
      					gprintf "Mux not ready... Sleeping 1 second\n"
      					sleep 1
				fi
				gprintf "Creating hardlink from %s/mux to %s/\n" "$SOCKETDIR" "${PFDIR}${SOCKETDIR}"
				ln -f $SOCKETDIR/mux ${PFDIR}${SOCKETDIR}/
				ln -f $SOCKETDIR/mux ${PFDIR}${OLDSOCKETDIR}/
				ln -f $SOCKETDIR/mux ${OLDSOCKETDIR}/
			fi
		fi
	fi
	# Get rid of any potential leftovers...
	[ -f $OLDPIDFILE ] && rm -f $OLDPIDFILE
	[ -f ${OLDSOCKETDIR}/mux.accept ] && rm -f ${OLDSOCKETDIR}/mux.accept 
	return $RETVAL
}

stop() {
	gprintf "Stopping %s: " $PROG
	[ ! -f $PIDFILE -a -f $OLDPIDFILE ] && local PIDFILE="$OLDPIDFILE"
	killproc -p $PIDFILE $PROG
	RETVAL=$?
	echo
	if [ $RETVAL -eq 0 ]; then
	       	rm -f $LOCKFILE
		if [ -e ${PFDIR}${SOCKETDIR}/mux ]; then
			gprintf "Deleting %s/mux\n" "${PFDIR}${SOCKETDIR}"
			rm -f ${PFDIR}${SOCKETDIR}/mux ${PFDIR}${OLDSOCKETDIR}/mux ${OLDSOCKETDIR}/mux
		fi
	fi
	return $RETVAL
}

rh_status() {
	[ ! -f $PIDFILE -a -f $OLDPIDFILE ] && local PIDFILE="$OLDPIDFILE"
	status -p $PIDFILE -l $LOCKFILE $PROG
	RETVAL=$?
	return $RETVAL
}

rh_status_q() {
	return $(rh_status >/dev/null 2>&1)
}            

# See how we were called.
case "$1" in
  start)
	rh_status_q && exit 0
	$1
	;;
  stop)
	$1
	;;
  status)
	rh_status
	;;
  restart|reload)
	stop
	start
	;;
  condrestart|try-restart)
	rh_status_q || exit 0
	stop
	start
        ;;
  *)
        gprintf "Usage: %s {start|stop|status|restart|condrestart}\n" $0
	RETVAL=2
	;;
esac

exit $RETVAL
